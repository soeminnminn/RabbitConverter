<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    
    string directory = Path.Combine(System.IO.Path.GetDirectoryName(this.Host.TemplateFile), "Resources");
    const string fileName = "material_icons_codepoints";
    string variablesPaths = Path.Combine(directory, fileName);
    
    Regex variableRegex = new Regex("^([^\\s]+)\\s([0-9a-f]+)$", RegexOptions.Compiled);
    
    const string visibility = "public";
    string namespaceHint = (string)System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint");
    string @namespace = namespaceHint ?? "MaterialIcons";
    
    const bool generateEnum = true;
    const bool generateConstants = true;
    const bool generateDictionary = false;
    const bool generateWpfExtensions = true;

    // Enumerate font variable
    List<NameValue> pairs = new List<NameValue>();
    using (StreamReader reader = new StreamReader(variablesPaths))
    {
        string line;
        while((line = reader.ReadLine()) != null)
        {
            Match match = variableRegex.Match(line);
            if (match.Success) 
            {
                pairs.Add(new NameValue(match.Groups[1].ToString(), match.Groups[2].ToString()));
            }
            
        }
    } 

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#= Environment.Version #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= @namespace #> 
{
<#
	if(generateWpfExtensions)
	{
#>
	using System;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Text;
	using System.Windows.Markup;	

<#
	}

	if(generateEnum)
	{
#>
    /// <summary>
    /// Material Icons.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    <#= visibility #> enum MaterialIconEnum
    {
<#
		foreach(NameValue pair in pairs)
		{
#>

        /// <summary>
        /// ic_<#= pair.Name #> (<#= pair.Value #>)
        /// </summary>
        <#= CamelName(pair.Name) #> = 0x<#= pair.Value #>,
<#		
		} 
	}
#>
    }

    /// <summary>
    /// Material Icons.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    <#= visibility #> static partial class MaterialIcons
    {
<#
	if (generateConstants)
	{
	    foreach (NameValue pair in pairs)
	    {
#>

        /// <summary>
        /// ic_<#= pair.Name #> (<#= pair.Value #>)
        /// </summary>
        public const string <#= CamelName(pair.Name) #> = "\u<#= pair.Value #>";
<#
	    }
	}

	if(generateDictionary)
	{
#>
		private static IDictionary<string, string> _allIcons;
        
		public static IDictionary<string, string> AllIcons
        {
            get { return _allIcons; }
        }

        static MaterialIcons()
        {
            _allIcons = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
<#
	HashSet<string> strings = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
	foreach(NameValue pair in pairs)
    {
		if(!strings.Contains(pair.Name))
		{
			strings.Add(pair.Name);
#>
            _allIcons.Add("<#= pair.Name #>", "\u<#= pair.Value #>");
<#
		}
		if(!strings.Contains(CamelName(pair.Name)))
		{
			strings.Add(CamelName(pair.Name));
#>
            _allIcons.Add("<#= CamelName(pair.Name) #>", "\u<#= pair.Value #>");
<#		
		}
    } 
#>
		}

<# 
	}
#>
    }
<#
    if (generateWpfExtensions)
    {
#>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= GetType().ToString() #>", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [MarkupExtensionReturnType(typeof(string))]
    <#= visibility #> partial class IconExtension : MarkupExtension
    {
        public IconExtension()
        {
        }
        
        public IconExtension(MaterialIconEnum icon)
        {
            Icon = icon;
        }
        
        [ConstructorArgument("icon")]
        public MaterialIconEnum Icon { get; set; }

        public override object ProvideValue(IServiceProvider serviceProvider)
        {
            return ((char)Icon).ToString();
        }
	}
<#
    }
#>
}
<#+

    class NameValue
    {
        public NameValue(string name, string value)
        {
            Name = name;
            Value = value;
        }

        public string Name { get; set; }
        public string Value { get; set; }
    }

    Regex nameFixRegex = new Regex("^([\\d]+)", RegexOptions.Compiled);

    string CamelName(string name)
    {
        StringBuilder sb = new StringBuilder();
        bool upperCase = true;
        foreach(char c in name)
        {
            if(c == '-' || c == '_')
            {
                upperCase = true;
                continue;
            }

            if(upperCase)
            {
                sb.Append(char.ToUpper(c));
            }
            else
            {
                sb.Append(c);
            }

            upperCase = false;
        }
        
        return nameFixRegex.Replace(sb.ToString(), "_$1");
    }

#>